<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Preview - {{ file.original_filename }}</title>
  <link rel="manifest" href="/static/manifest.json" />
  <meta name="theme-color" content="#6366f1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/3MFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #18181b; }
    #viewer { width: 100vw; height: 100vh; }
    .overlay { position: absolute; z-index: 10; }
  </style>
</head>
<body class="bg-zinc-900 text-white">
  <!-- Header -->
  <div class="overlay top-0 left-0 right-0 bg-zinc-900/90 backdrop-blur border-b border-zinc-800 p-4">
    <div class="flex items-center justify-between max-w-7xl mx-auto">
      <div class="flex items-center gap-4">
        <a href="/my/{{ req_id }}?token={{ token }}" class="text-zinc-400 hover:text-white transition">
          ‚Üê Back
        </a>
        <div>
          <h1 class="font-semibold truncate max-w-[200px] sm:max-w-md">{{ file.original_filename }}</h1>
          {% if metadata and metadata.dimensions_mm %}
          <p class="text-xs text-zinc-400">
            üìê {{ metadata.dimensions_mm.x }} √ó {{ metadata.dimensions_mm.y }} √ó {{ metadata.dimensions_mm.z }} mm
            {% if metadata.volume_cm3 %}‚Ä¢ {{ metadata.volume_cm3 }} cm¬≥{% endif %}
          </p>
          {% endif %}
        </div>
      </div>
      <div class="flex items-center gap-2">
        <a href="{{ file_url }}" download class="px-3 py-1.5 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-sm font-medium transition">
          Download
        </a>
      </div>
    </div>
  </div>

  <!-- 3D Viewer -->
  <div id="viewer"></div>

  <!-- Controls Overlay (collapsible on mobile) -->
  <div class="overlay bottom-4 left-4 right-4 sm:right-auto bg-zinc-900/90 backdrop-blur border border-zinc-700 rounded-lg">
    <button onclick="toggleControls()" class="sm:hidden w-full p-3 flex items-center justify-between text-sm font-medium">
      <span>‚öôÔ∏è Controls</span>
      <span id="controls-arrow">‚ñº</span>
    </button>
    <div id="controls-panel" class="hidden sm:block p-4 pt-0 sm:pt-4">
      <h3 class="text-sm font-medium mb-2 hidden sm:block">Controls</h3>
      <ul class="text-xs text-zinc-400 space-y-1">
        <li>üñ±Ô∏è Left drag: Rotate</li>
        <li>üñ±Ô∏è Right drag: Pan</li>
        <li>üñ±Ô∏è Scroll: Zoom</li>
      </ul>
      <div class="mt-3 pt-3 border-t border-zinc-700">
        <label class="text-xs text-zinc-400 block mb-1">Model Color</label>
        <input type="color" id="model-color" value="#6366f1" class="w-full h-8 rounded cursor-pointer">
      </div>
      <div class="mt-2">
        <label class="flex items-center gap-2 text-xs text-zinc-400 cursor-pointer">
          <input type="checkbox" id="wireframe" class="rounded">
          Wireframe
        </label>
      </div>
      <div class="mt-2">
        <button id="reset-camera" class="w-full px-3 py-1.5 rounded bg-zinc-700 hover:bg-zinc-600 text-xs transition">
          Reset Camera
        </button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loading" class="fixed inset-0 bg-zinc-900 flex items-center justify-center z-50">
    <div class="text-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-500 border-t-transparent mx-auto mb-4"></div>
      <p class="text-zinc-400">Loading 3D model...</p>
    </div>
  </div>

  <!-- Error Overlay -->
  <div id="error" class="hidden fixed inset-0 bg-zinc-900 flex items-center justify-center z-50">
    <div class="text-center p-6">
      <div class="text-4xl mb-4">‚ö†Ô∏è</div>
      <p class="text-red-400 mb-2">Failed to load 3D model</p>
      <p id="error-message" class="text-xs text-zinc-500 mb-4"></p>
      <a href="/my/{{ req_id }}?token={{ token }}" class="px-4 py-2 rounded-lg bg-zinc-700 hover:bg-zinc-600 text-sm transition inline-block">
        Go Back
      </a>
    </div>
  </div>

  <script>
    const fileUrl = "{{ file_url }}";
    const fileName = "{{ file.original_filename }}";
    const fileExt = fileName.toLowerCase().split('.').pop();
    
    let scene, camera, renderer, controls, mesh;
    let initialCameraPosition, initialControlsTarget;

    function toggleControls() {
      const panel = document.getElementById('controls-panel');
      const arrow = document.getElementById('controls-arrow');
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        arrow.textContent = '‚ñ≤';
      } else {
        panel.classList.add('hidden');
        arrow.textContent = '‚ñº';
      }
    }

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x18181b);

      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(100, 100, 100);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('viewer').appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      // Touch support
      controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
      };

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight1.position.set(1, 1, 1);
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-1, -1, -1);
      scene.add(directionalLight2);

      // Grid helper
      const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x333333);
      scene.add(gridHelper);

      // Load model
      loadModel();

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      document.getElementById('model-color').addEventListener('input', onColorChange);
      document.getElementById('wireframe').addEventListener('change', onWireframeChange);
      document.getElementById('reset-camera').addEventListener('click', resetCamera);

      animate();
    }

    function loadModel() {
      let loader;
      if (fileExt === 'stl') {
        loader = new THREE.STLLoader();
      } else if (fileExt === '3mf') {
        loader = new THREE.ThreeMFLoader();
      } else {
        loader = new THREE.OBJLoader();
      }
      
      loader.load(
        fileUrl,
        function(result) {
          document.getElementById('loading').classList.add('hidden');
          
          // Handle different loader results
          if (fileExt === '3mf') {
            // 3MF loader returns a Group with meshes
            handle3MFResult(result);
            return;
          }
          
          let finalGeometry;
          if (fileExt === 'stl') {
            finalGeometry = result;
          } else {
            // OBJ loader returns a group
            if (result.children && result.children.length > 0) {
              finalGeometry = result.children[0].geometry;
            } else {
              finalGeometry = result;
            }
          }
          
          // Center the geometry
          finalGeometry.computeBoundingBox();
          const center = new THREE.Vector3();
          finalGeometry.boundingBox.getCenter(center);
          finalGeometry.translate(-center.x, -center.y, -center.z);
          
          // Move to sit on grid (Y = 0 at bottom)
          const minY = finalGeometry.boundingBox.min.y - center.y;
          finalGeometry.translate(0, -minY, 0);
          
          // Material
          const material = new THREE.MeshPhongMaterial({
            color: 0x6366f1,
            specular: 0x111111,
            shininess: 30,
            flatShading: false
          });
          
          mesh = new THREE.Mesh(finalGeometry, material);
          scene.add(mesh);
          
          // Fit camera to model
          fitCameraToObject(mesh);
          
          // Store initial camera state for reset
          initialCameraPosition = camera.position.clone();
          initialControlsTarget = controls.target.clone();
        },
        function(xhr) {
          // Progress
          if (xhr.lengthComputable) {
            const percent = Math.round((xhr.loaded / xhr.total) * 100);
            console.log(`Loading: ${percent}%`);
          }
        },
        function(error) {
          console.error('Error loading model:', error);
          document.getElementById('loading').classList.add('hidden');
          document.getElementById('error').classList.remove('hidden');
          document.getElementById('error-message').textContent = error.message || 'Unknown error';
        }
      );
    }

    function handle3MFResult(group) {
      // 3MF loader returns a Group containing meshes
      // Center the entire group
      const box = new THREE.Box3().setFromObject(group);
      const center = new THREE.Vector3();
      box.getCenter(center);
      group.position.sub(center);
      
      // Move to sit on grid
      const newBox = new THREE.Box3().setFromObject(group);
      group.position.y -= newBox.min.y;
      
      // Apply our material to all meshes in the group (for color/wireframe controls)
      const material = new THREE.MeshPhongMaterial({
        color: 0x6366f1,
        specular: 0x111111,
        shininess: 30,
        flatShading: false
      });
      
      group.traverse(function(child) {
        if (child.isMesh) {
          child.material = material;
        }
      });
      
      mesh = group;
      scene.add(group);
      
      // Fit camera to model
      fitCameraToObject(group);
      
      // Store initial camera state for reset
      initialCameraPosition = camera.position.clone();
      initialControlsTarget = controls.target.clone();
    }

    function fitCameraToObject(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      
      const fov = camera.fov * (Math.PI / 180);
      let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
      cameraDistance *= 1.5; // Add some padding
      
      const direction = new THREE.Vector3(1, 0.5, 1).normalize();
      camera.position.copy(direction.multiplyScalar(cameraDistance));
      
      controls.target.set(0, size.y / 2, 0);
      controls.update();
    }

    function resetCamera() {
      if (initialCameraPosition && initialControlsTarget) {
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialControlsTarget);
        controls.update();
      }
    }

    function onColorChange(e) {
      if (mesh) {
        if (mesh.isMesh) {
          mesh.material.color.set(e.target.value);
        } else {
          // Handle groups (3MF)
          mesh.traverse(function(child) {
            if (child.isMesh) {
              child.material.color.set(e.target.value);
            }
          });
        }
      }
    }

    function onWireframeChange(e) {
      if (mesh) {
        if (mesh.isMesh) {
          mesh.material.wireframe = e.target.checked;
        } else {
          // Handle groups (3MF)
          mesh.traverse(function(child) {
            if (child.isMesh) {
              child.material.wireframe = e.target.checked;
            }
          });
        }
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
